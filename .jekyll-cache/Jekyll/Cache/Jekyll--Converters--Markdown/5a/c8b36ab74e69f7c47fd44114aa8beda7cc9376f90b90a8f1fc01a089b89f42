I"><p>Four classes of Algorithms:</p>

<p>1) Bagging of SVMs 2) RandomForest 3) Neural Networks 4) LinearModels</p>

<p><strong>Pick a robust methodology.</strong> Here is the tricky part which depends on experience, even if you have done cross validation, you can still get burned: Sketchy methods of improving the CV score like making cubic features, cubic root features, boosting like crazy, magical numbers(without understanding it), etc, will likely be a bad model to pick even if the CV score is good. Unfortunately, you will probably have to make this mistake once to know what this means</p>

<p>check for duplicate entry</p>

<p>check for outliers (extraordinary ‘Y’ values)</p>

<p>check variables ‘X’s and how they correlate with ‘Y’</p>

<pre><code>what should i do here?
This helps determine how to do feature engineering.For example, creating two groups one for good selling month, another for all others
     # Months with the largest number of deals may be significant.
        all_df["HighSeason"] = df["MoSold"].replace( 
            {1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0})
</code></pre>

<p>check correlation between variables if necessary</p>

<pre><code>what should i do here?
</code></pre>

<p>distinguish between categorical variable and numerical variable(sometimes, numerical is actually categorical. Sometimes change categorical to numerical keeps the information in their order) actually we can separate them in the first place, and concatenate them later</p>

<blockquote>
  <p>in python&amp;pandas, this can be done like this:(take care to exclude ‘Y’)</p>

  <pre><code class="language-python">categorical_features = train.select_dtypes(include = ["object"]).columns
numerical_features = train.select_dtypes(exclude = ["object"]).columns
</code></pre>
</blockquote>

<p>fill missing values:</p>

<blockquote>
  <p>for some, mean/media/most-common-value makes sense</p>

  <p>for others, maybe add new category or somthing</p>
</blockquote>

<p>feature engineering:</p>

<ul>
  <li>simplify existing features</li>
  <li>combine existing features</li>
  <li>create new features on top-correlation (with ‘Y’) features, ^2, ^3, sqrt…</li>
</ul>

<blockquote>
  <p>don’t make interaction with dummy variables(0,1)!</p>
</blockquote>

<pre><code>why polynomials?
</code></pre>

<p>log-transform</p>

<pre><code>why take log transformation?
	log transformation can decrease the variability of data and make data conform more closely to the normal distribution, lessen the impact of outliers(skewness &gt; 0.5 is skewed)
	make relative comparison rather than absolute comparison
</code></pre>

<p>create dummy variables via one-hot encoding</p>

<p>partition</p>

<blockquote>
  <p>train_test_split()</p>
</blockquote>

<p>normalize</p>

<blockquote>
  <p>fit the StandardScaler model on training data, and fit it on test data. do partitioning before normalizing</p>

  <p>do not z-normalize categorical variables</p>

  <p>normalize after polynomial features/create interaction features</p>
</blockquote>

<pre><code>why z-normalize features?
	because it helps to make the coefficient meaningful. (not the case for decision tree and random forest)
	
why not z-normalize categorical features?
why z-normalize after generating polynomial/interaction features?
</code></pre>

<p>define a scorer, a regularization term and a model</p>

<blockquote>
  <p>regularization help avoid unstable state introduced by variable correlation, e.g. one large positive coefficient is cancelled by another large negative coefficient. And regularization helps prevent that</p>

  <p>elasticnet is a compromise between L1(Lasso) and L2(Ridge) regularization</p>
</blockquote>

<pre><code>if regularization is used, is it necessary to deal with correlated variables in the beginning?

what's the difference between L1 and L2 regularization?
In contrast to L2 regularization, L1 regularization yields sparse feature vectors : most feature weights will be zero. Sparsity can be useful in practice if we have a high dimensional dataset with many features that are irrelevant.

why L2 is called Ridge?

</code></pre>

<p>determine parameters, find the best and perform a more precise search around the now-best parameter</p>

<p>L1 v.s. L2</p>

<table>
  <thead>
    <tr>
      <th>Usage</th>
      <th>L2</th>
      <th>L1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Regularization term</td>
      <td>computationally efficient</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>sparse(feature selection)</td>
    </tr>
    <tr>
      <td> </td>
      <td>solution uniqueness</td>
      <td> </td>
    </tr>
    <tr>
      <td>Loss function</td>
      <td> </td>
      <td>robust(less sensitive to outliers)</td>
    </tr>
    <tr>
      <td> </td>
      <td>stable soution</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>solution uniqueness</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<pre><code>what's the differences between stability and robustness?
</code></pre>

:ET